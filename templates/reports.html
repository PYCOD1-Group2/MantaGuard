{% extends "base.html" %}

{% block title %}Reports{% endblock %}

{% block extra_css %}
<style>
    /* Professional cybersecurity themed variables */
    :root {
        --cyber-primary: #4CAF50;
        --cyber-secondary: #2196F3;
        --cyber-accent: #F44336;
        --cyber-warning: #FF9800;
        --cyber-success: #4CAF50;
        --cyber-bg-dark: #121212;
        --cyber-bg-card: #1e1e1e;
        --cyber-bg-hover: #2a2a2a;
        --cyber-border: rgba(255, 255, 255, 0.12);
        --cyber-border-accent: rgba(76, 175, 80, 0.3);
        --cyber-text: #ffffff;
        --cyber-text-secondary: #b0b0b0;
        --cyber-text-dim: #757575;
        --cyber-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        --cyber-shadow-hover: 0 8px 24px rgba(0, 0, 0, 0.2);
    }


    /* Professional metric cards */
    .metric-card {
        background: var(--cyber-bg-card);
        border-radius: 8px;
        padding: 24px;
        text-align: center;
        border: 1px solid var(--cyber-border);
        transition: all 0.3s ease;
        height: 100%;
        box-shadow: var(--cyber-shadow);
    }

    .metric-card:hover {
        border-color: var(--cyber-border-accent);
        transform: translateY(-2px);
        box-shadow: var(--cyber-shadow-hover);
        background: var(--cyber-bg-hover);
    }

    .metric-number {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--cyber-primary);
        margin-bottom: 8px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    }

    .metric-label {
        color: var(--cyber-text-secondary);
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 500;
    }

    /* Professional cards */
    .card {
        background: var(--cyber-bg-card);
        border: 1px solid var(--cyber-border);
        border-radius: 8px;
        box-shadow: var(--cyber-shadow);
        transition: all 0.3s ease;
    }

    .card:hover {
        border-color: var(--cyber-border-accent);
        box-shadow: var(--cyber-shadow-hover);
    }

    .card-header {
        background: rgba(255, 255, 255, 0.03);
        border-bottom: 1px solid var(--cyber-border);
        padding: 20px;
        border-radius: 8px 8px 0 0 !important;
    }

    .card-header h5 {
        color: var(--cyber-text);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0;
        font-size: 0.9rem;
    }

    /* Professional timeline */
    .scan-timeline {
        max-height: 500px;
        overflow-y: auto;
        padding-right: 10px;
    }

    .scan-timeline::-webkit-scrollbar {
        width: 6px;
    }

    .scan-timeline::-webkit-scrollbar-track {
        background: var(--cyber-bg-dark);
        border-radius: 3px;
    }

    .scan-timeline::-webkit-scrollbar-thumb {
        background: var(--cyber-text-dim);
        border-radius: 3px;
    }

    .scan-timeline::-webkit-scrollbar-thumb:hover {
        background: var(--cyber-primary);
    }

    .timeline-item {
        border-left: 3px solid var(--cyber-primary);
        padding-left: 20px;
        margin-bottom: 16px;
        position: relative;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 0 6px 6px 0;
        padding: 12px 16px 12px 20px;
    }

    .timeline-item::before {
        content: '';
        position: absolute;
        left: -6px;
        top: 12px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: var(--cyber-primary);
        border: 2px solid var(--cyber-bg-dark);
    }

    .timeline-item.high-severity {
        border-left-color: var(--cyber-accent);
        background: rgba(244, 67, 54, 0.05);
    }

    .timeline-item.high-severity::before {
        background-color: var(--cyber-accent);
    }

    .timeline-item.medium-severity {
        border-left-color: var(--cyber-warning);
        background: rgba(255, 152, 0, 0.05);
    }

    .timeline-item.medium-severity::before {
        background-color: var(--cyber-warning);
    }

    /* Professional protocol bars */
    .protocol-bar {
        background: var(--cyber-bg-dark);
        height: 20px;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
        position: relative;
        border: 1px solid var(--cyber-border);
    }

    .protocol-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--cyber-primary), var(--cyber-secondary));
        transition: width 0.3s ease;
    }

    .protocol-label {
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.75rem;
        color: var(--cyber-text);
        font-weight: 500;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
    }

    /* Professional severity badges */
    .severity-badge {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border: 1px solid;
    }

    .severity-high {
        background: rgba(244, 67, 54, 0.1);
        color: var(--cyber-accent);
        border-color: var(--cyber-accent);
    }

    .severity-medium {
        background: rgba(255, 152, 0, 0.1);
        color: var(--cyber-warning);
        border-color: var(--cyber-warning);
    }

    .severity-low {
        background: rgba(76, 175, 80, 0.1);
        color: var(--cyber-primary);
        border-color: var(--cyber-primary);
    }

    /* Professional scan items */
    .scan-item {
        background: var(--cyber-bg-card);
        border-radius: 6px;
        padding: 16px;
        margin-bottom: 8px;
        border: 1px solid var(--cyber-border);
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .scan-item:hover {
        border-color: var(--cyber-border-accent);
        background: var(--cyber-bg-hover);
        transform: translateX(2px);
        box-shadow: var(--cyber-shadow);
    }

    /* Professional buttons */
    .btn-outline-primary {
        color: var(--cyber-primary);
        border-color: var(--cyber-primary);
        background: transparent;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .btn-outline-primary:hover {
        background-color: var(--cyber-primary);
        border-color: var(--cyber-primary);
        color: var(--cyber-bg-dark);
    }

    .btn-primary {
        background: var(--cyber-primary);
        border: none;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .btn-primary:hover {
        background: #45a049;
        transform: translateY(-1px);
        box-shadow: var(--cyber-shadow);
    }


    /* Professional loading spinner */
    .loading-spinner {
        display: none;
        text-align: center;
        padding: 40px;
    }

    .spinner-border {
        border-color: rgba(255, 255, 255, 0.1);
        border-top-color: var(--cyber-primary);
    }

    /* Professional anomaly rate styling */
    .anomaly-rate-high {
        color: var(--cyber-accent);
        font-weight: 600;
    }

    .anomaly-rate-medium {
        color: var(--cyber-warning);
        font-weight: 600;
    }

    .anomaly-rate-low {
        color: var(--cyber-primary);
        font-weight: 600;
    }

    /* Professional headings */
    h1, h5, h6 {
        color: var(--cyber-text);
    }

    h1 {
        font-weight: 700;
        color: var(--cyber-text);
    }

    /* Professional table styling for modal */
    .table-dark {
        background: var(--cyber-bg-card);
        border: 2px solid rgba(0, 191, 255, 0.3) !important;
        border-radius: 8px !important;
        overflow: hidden !important;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        margin-bottom: 1rem !important;
    }

    .table-dark th {
        background: rgba(255, 255, 255, 0.03);
        color: var(--cyber-text-secondary);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-color: var(--cyber-border);
        font-size: 0.8rem;
        border-bottom: 2px solid #00BFFF !important;
        border-top: none !important;
        border-left: none !important;
        border-right: none !important;
    }

    .table-dark td {
        border-color: var(--cyber-border);
        color: var(--cyber-text);
        border-left: none !important;
        border-right: none !important;
    }

    .table-dark tbody tr:hover {
        background: rgba(255, 255, 255, 0.02);
    }

    /* Additional table frame styling for modal tables */
    .table-dark thead th:first-child {
        border-top-left-radius: 6px !important;
    }

    .table-dark thead th:last-child {
        border-top-right-radius: 6px !important;
    }

    .table-dark tbody tr:last-child td:first-child {
        border-bottom-left-radius: 6px !important;
    }

    .table-dark tbody tr:last-child td:last-child {
        border-bottom-right-radius: 6px !important;
    }

    /* Professional checkbox styling */
    input[type="checkbox"] {
        accent-color: var(--cyber-primary);
        transform: scale(1.1);
    }

    /* Professional form switch styling */
    .form-check-input:checked {
        background-color: var(--cyber-primary);
        border-color: var(--cyber-primary);
    }

    .form-check-label {
        color: var(--cyber-text-secondary);
        font-weight: 500;
        font-size: 0.9rem;
    }

    /* Professional Toast Styling */
    .toast-container {
        z-index: 1060;
    }

    .toast {
        background: var(--cyber-bg-card);
        border: 1px solid var(--cyber-border);
        border-radius: 8px;
        box-shadow: var(--cyber-shadow-hover);
        backdrop-filter: blur(8px);
        min-width: 350px;
    }

    .toast.border-success {
        border-color: var(--cyber-primary);
        border-left: 4px solid var(--cyber-primary);
    }

    .toast.border-danger {
        border-color: var(--cyber-accent);
        border-left: 4px solid var(--cyber-accent);
    }

    .toast-header {
        background: rgba(255, 255, 255, 0.03);
        border-bottom: 1px solid var(--cyber-border);
        color: var(--cyber-text);
        font-weight: 600;
        border-radius: 8px 8px 0 0;
    }

    .toast-body {
        color: var(--cyber-text);
        padding: 16px;
        font-weight: 400;
    }

    .toast-body code {
        background: rgba(255, 255, 255, 0.05);
        color: var(--cyber-primary);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        border: 1px solid var(--cyber-border);
        font-size: 0.85em;
    }

    .btn-close {
        filter: invert(1) brightness(0.8);
    }

    /* Text color overrides */
    .text-muted {
        color: var(--cyber-text-dim) !important;
    }

    /* Professional tab styling for visualizations */
    .nav-tabs {
        border-bottom: 1px solid var(--cyber-border);
    }

    .nav-tabs .nav-link {
        background: transparent;
        border: 1px solid transparent;
        color: var(--cyber-text-secondary);
        font-weight: 500;
        padding: 8px 16px;
        margin-right: 2px;
        border-radius: 6px 6px 0 0;
        transition: all 0.2s ease;
    }

    .nav-tabs .nav-link:hover {
        background: rgba(255, 255, 255, 0.05);
        color: var(--cyber-text);
        border-color: var(--cyber-border);
    }

    .nav-tabs .nav-link.active {
        background: var(--cyber-bg-card);
        color: var(--cyber-primary);
        border-color: var(--cyber-border) var(--cyber-border) var(--cyber-bg-card);
        border-bottom-color: var(--cyber-bg-card);
    }

    .tab-content {
        border: 1px solid var(--cyber-border);
        border-top: none;
        border-radius: 0 6px 6px 6px;
        background: var(--cyber-bg-card);
        min-height: 400px;
    }

    .tab-pane {
        padding: 20px;
    }

    .visualization-container {
        text-align: center;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .visualization-container img {
        max-width: 100%;
        max-height: 350px;
        object-fit: contain;
        border-radius: 4px;
        box-shadow: var(--cyber-shadow);
    }

    .no-visualization {
        color: var(--cyber-text-dim);
        font-style: italic;
        text-align: center;
        padding: 60px 20px;
    }

    /* Professional badge styling */
    .badge {
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
    }

    .bg-danger {
        background: var(--cyber-accent) !important;
    }

    .bg-success {
        background: var(--cyber-primary) !important;
    }

    /* Professional modal styling */
    .modal-content {
        background: var(--cyber-bg-card) !important;
        border: 1px solid var(--cyber-border) !important;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4) !important;
        border-radius: 8px !important;
    }

    .modal-header {
        border-bottom: 1px solid var(--cyber-border) !important;
        background: rgba(255, 255, 255, 0.02) !important;
        border-radius: 8px 8px 0 0 !important;
    }

    .modal-title {
        color: var(--cyber-text) !important;
        font-weight: 600 !important;
        font-size: 1.1rem !important;
    }

    /* Professional button styling for small buttons */
    .btn-xs {
        padding: 2px 6px;
        font-size: 0.75rem;
        border-radius: 3px;
    }

    .btn-outline-secondary {
        color: var(--cyber-text-secondary);
        border-color: var(--cyber-border);
        background: transparent;
        transition: all 0.2s ease;
    }

    .btn-outline-secondary:hover {
        background-color: var(--cyber-text-secondary);
        border-color: var(--cyber-text-secondary);
        color: var(--cyber-bg-dark);
    }

    /* Gap utility for flexbox */
    .gap-3 {
        gap: 1rem;
    }

    /* Visual indicators for extracted connections */
    .extracted-connection {
        background: rgba(76, 175, 80, 0.05) !important;
        border-left: 3px solid var(--cyber-primary) !important;
    }

    .extracted-connection:hover {
        background: rgba(76, 175, 80, 0.1) !important;
    }

    /* Success button styling */
    .btn-success {
        background: var(--cyber-primary) !important;
        border-color: var(--cyber-primary) !important;
        color: var(--cyber-bg-dark) !important;
    }

    .btn-success:hover {
        background: #45a049 !important;
        border-color: #45a049 !important;
        color: var(--cyber-bg-dark) !important;
    }

    /* Text color utilities */
    .text-success {
        color: var(--cyber-primary) !important;
    }

    .text-warning {
        color: var(--cyber-warning) !important;
    }

    .text-info {
        color: var(--cyber-secondary) !important;
    }

    /* Warning button styling */
    .btn-warning {
        background: var(--cyber-warning) !important;
        border-color: var(--cyber-warning) !important;
        color: var(--cyber-bg-dark) !important;
        font-weight: 600;
    }

    .btn-warning:hover {
        background: #e6a700 !important;
        border-color: #e6a700 !important;
        color: var(--cyber-bg-dark) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1><i class="fas fa-chart-bar me-2"></i>Security Reports & Analytics</h1>
                <button class="btn btn-outline-primary" onclick="refreshReports()">
                    <i class="fas fa-sync-alt me-2"></i>Refresh Data
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loading-spinner" class="loading-spinner">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading analytics data...</p>
    </div>

    <!-- Main Content -->
    <div id="reports-content">
        <!-- Key Metrics -->
        <div class="row mb-4">
            <div class="col-md-3 mb-3">
                <div class="metric-card">
                    <div class="metric-number" id="total-scans">{{ analytics.total_scans }}</div>
                    <div class="metric-label">Total Scans</div>
                </div>
            </div>
            <div class="col-md-3 mb-3">
                <div class="metric-card">
                    <div class="metric-number" id="total-connections">{{ analytics.total_connections }}</div>
                    <div class="metric-label">Connections Analyzed</div>
                </div>
            </div>
            <div class="col-md-3 mb-3">
                <div class="metric-card">
                    <div class="metric-number" id="anomaly-count" style="color: #dc3545;">{{ analytics.anomaly_count }}</div>
                    <div class="metric-label">Anomalies Detected</div>
                </div>
            </div>
            <div class="col-md-3 mb-3">
                <div class="metric-card">
                    <div class="metric-number" id="anomaly-rate" style="color: #ffc107;">{{ analytics.network_activity.anomaly_rate }}%</div>
                    <div class="metric-label">Anomaly Rate</div>
                </div>
            </div>
        </div>

        <!-- Charts Row -->
        <div class="row mb-4">
            <!-- Protocol Distribution -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-network-wired me-2"></i>Protocol Distribution</h5>
                    </div>
                    <div class="card-body">
                        <div id="protocol-chart">
                            {% if analytics.protocol_distribution %}
                                {% set total_protocols = analytics.protocol_distribution.values() | sum %}
                                {% for protocol, count in analytics.protocol_distribution.items() %}
                                <div class="mb-3">
                                    <div class="d-flex justify-content-between mb-1">
                                        <small>{{ protocol.upper() }}</small>
                                        <small>{{ count }} ({{ "%.1f"|format((count / total_protocols * 100) if total_protocols > 0 else 0) }}%)</small>
                                    </div>
                                    <div class="protocol-bar">
                                        <div class="protocol-fill" style="width: {{ (count / total_protocols * 100) if total_protocols > 0 else 0 }}%"></div>
                                    </div>
                                </div>
                                {% endfor %}
                            {% else %}
                                <p class="text-muted">No protocol data available</p>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Threat Timeline -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-exclamation-triangle me-2"></i>Recent Threats</h5>
                    </div>
                    <div class="card-body">
                        <div class="scan-timeline" id="threat-timeline">
                            {% if analytics.threat_timeline %}
                                {% for threat in analytics.threat_timeline %}
                                <div class="timeline-item {{ threat.severity }}-severity">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <strong>{{ threat.threat_count }} Anomalies</strong>
                                            <br><small class="text-muted">{{ threat.timestamp }}</small>
                                        </div>
                                        <span class="severity-badge severity-{{ threat.severity }}">{{ threat.severity }}</span>
                                    </div>
                                </div>
                                {% endfor %}
                            {% else %}
                                <p class="text-muted">No recent threats detected</p>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recent Scans -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-history me-2"></i>Scan History</h5>
                    </div>
                    <div class="card-body">
                        <div id="recent-scans">
                            {% if analytics.recent_scans %}
                                {% for scan in analytics.recent_scans %}
                                <div class="scan-item" onclick="viewScanDetails('{{ scan.directory }}')">
                                    <div class="row align-items-center">
                                        <div class="col-md-2">
                                            <strong>{{ scan.timestamp }}</strong>
                                        </div>
                                        <div class="col-md-2">
                                            <i class="fas fa-{% if scan.origin_type == 'timed_capture' %}clock{% elif scan.origin_type == 'upload' %}upload{% else %}question{% endif %} me-1"></i>
                                            <small>{{ scan.origin_description }}</small>
                                        </div>
                                        <div class="col-md-2">
                                            <i class="fas fa-link me-1"></i>{{ scan.connections }} connections
                                        </div>
                                        <div class="col-md-2">
                                            <i class="fas fa-exclamation-circle me-1"></i>{{ scan.anomalies }} anomalies
                                        </div>
                                        <div class="col-md-2">
                                            <span class="anomaly-rate-{% if scan.anomaly_rate > 50 %}high{% elif scan.anomaly_rate > 20 %}medium{% else %}low{% endif %}">
                                                {{ scan.anomaly_rate }}% anomaly rate
                                            </span>
                                        </div>
                                        <div class="col-md-2 text-end">
                                            <button class="btn btn-sm btn-outline-primary">
                                                <i class="fas fa-eye me-1"></i>View Details
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                {% endfor %}
                            {% else %}
                                <div class="text-center py-5">
                                    <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                                    <h5 class="text-muted">No Scan History</h5>
                                    <p class="text-muted">Run your first network scan to see analytics here.</p>
                                    <a href="{{ url_for('monitoring') }}" class="btn btn-primary">
                                        <i class="fas fa-radar-chart me-2"></i>Start Scanning
                                    </a>
                                </div>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Toast Container -->
<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1060">
    <div id="extractionToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <i class="fas fa-download me-2 text-primary"></i>
            <strong class="me-auto">PCAP Extraction</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastBody">
            <!-- Toast message will be set dynamically -->
        </div>
    </div>
</div>

<!-- Scan Details Modal -->
<div class="modal fade" id="scanDetailsModal" tabindex="-1" data-bs-backdrop="true" data-bs-keyboard="true">
    <div class="modal-dialog" style="max-width: 95vw; width: 95vw;">
        <div class="modal-content" style="background-color: #1E1E1E; border: 1px solid rgba(255, 255, 255, 0.1);">
            <div class="modal-header" style="border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                <h5 class="modal-title" id="scanDetailsTitle">Scan Details</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" onclick="closeScanModal()"></button>
            </div>
            <div class="modal-body" id="scanDetailsBody">
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
function refreshReports() {
    const loadingSpinner = document.getElementById('loading-spinner');
    const reportsContent = document.getElementById('reports-content');

    loadingSpinner.style.display = 'block';
    reportsContent.style.opacity = '0.5';

    fetch('/api/reports/analytics')
    .then(response => response.json())
    .then(data => {
        updateMetrics(data);
        updateProtocolChart(data.protocol_distribution);
        updateThreatTimeline(data.threat_timeline);
        updateRecentScans(data.recent_scans);

        loadingSpinner.style.display = 'none';
        reportsContent.style.opacity = '1';
    })
    .catch(error => {
        console.error('Error refreshing reports:', error);
        loadingSpinner.style.display = 'none';
        reportsContent.style.opacity = '1';
    });
}

function updateMetrics(data) {
    document.getElementById('total-scans').textContent = data.total_scans;
    document.getElementById('total-connections').textContent = data.total_connections;
    document.getElementById('anomaly-count').textContent = data.anomaly_count;
    document.getElementById('anomaly-rate').textContent = data.network_activity.anomaly_rate + '%';
}

function updateProtocolChart(protocolData) {
    const chartContainer = document.getElementById('protocol-chart');
    const total = Object.values(protocolData).reduce((sum, count) => sum + count, 0);

    let html = '';
    for (const [protocol, count] of Object.entries(protocolData)) {
        const percentage = total > 0 ? (count / total * 100).toFixed(1) : 0;
        html += `
            <div class="mb-3">
                <div class="d-flex justify-content-between mb-1">
                    <small>${protocol.toUpperCase()}</small>
                    <small>${count} (${percentage}%)</small>
                </div>
                <div class="protocol-bar">
                    <div class="protocol-fill" style="width: ${percentage}%"></div>
                </div>
            </div>
        `;
    }

    if (html === '') {
        html = '<p class="text-muted">No protocol data available</p>';
    }

    chartContainer.innerHTML = html;
}

function updateThreatTimeline(threats) {
    const timelineContainer = document.getElementById('threat-timeline');

    let html = '';
    threats.forEach(threat => {
        html += `
            <div class="timeline-item ${threat.severity}-severity">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${threat.threat_count} Anomalies</strong>
                        <br><small class="text-muted">${threat.timestamp}</small>
                    </div>
                    <span class="severity-badge severity-${threat.severity}">${threat.severity}</span>
                </div>
            </div>
        `;
    });

    if (html === '') {
        html = '<p class="text-muted">No recent threats detected</p>';
    }

    timelineContainer.innerHTML = html;
}

function updateRecentScans(scans) {
    const scansContainer = document.getElementById('recent-scans');

    let html = '';
    scans.forEach(scan => {
        const severityClass = scan.anomaly_rate > 50 ? 'high' : scan.anomaly_rate > 20 ? 'medium' : 'low';

        // Format timestamp if it's in the old format (YYYYMMDD_HHMMSS)
        let formattedTimestamp = scan.timestamp;
        if (scan.timestamp.match(/^\d{8}_\d{6}$/)) {
            try {
                const dt = new Date(
                    scan.timestamp.slice(0, 4),  // year
                    scan.timestamp.slice(4, 6) - 1,  // month (0-indexed)
                    scan.timestamp.slice(6, 8),  // day
                    scan.timestamp.slice(9, 11), // hour
                    scan.timestamp.slice(11, 13), // minute
                    scan.timestamp.slice(13, 15)  // second
                );
                formattedTimestamp = dt.toLocaleDateString('en-GB', {
                    day: 'numeric',
                    month: 'short',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }).toUpperCase();
            } catch (e) {
                formattedTimestamp = scan.timestamp.replace('_', ' ');
            }
        }

        // Get origin icon based on type
        let originIcon = 'question';
        if (scan.origin_type === 'timed_capture') {
            originIcon = 'clock';
        } else if (scan.origin_type === 'upload') {
            originIcon = 'upload';
        }

        html += `
            <div class="scan-item" onclick="viewScanDetails('${scan.directory}')">
                <div class="row align-items-center">
                    <div class="col-md-2">
                        <strong>${formattedTimestamp}</strong>
                    </div>
                    <div class="col-md-2">
                        <i class="fas fa-${originIcon} me-1"></i>
                        <small>${scan.origin_description || 'Unknown Source'}</small>
                    </div>
                    <div class="col-md-2">
                        <i class="fas fa-link me-1"></i>${scan.connections} connections
                    </div>
                    <div class="col-md-2">
                        <i class="fas fa-exclamation-circle me-1"></i>${scan.anomalies} anomalies
                    </div>
                    <div class="col-md-2">
                        <span class="anomaly-rate-${severityClass}">
                            ${scan.anomaly_rate}% anomaly rate
                        </span>
                    </div>
                    <div class="col-md-2 text-end">
                        <button class="btn btn-sm btn-outline-primary">
                            <i class="fas fa-eye me-1"></i>View Details
                        </button>
                    </div>
                </div>
            </div>
        `;
    });

    if (html === '') {
        html = `
            <div class="text-center py-5">
                <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                <h5 class="text-muted">No Scan History</h5>
                <p class="text-muted">Run your first network scan to see analytics here.</p>
                <a href="/monitoring" class="btn btn-primary">
                    <i class="fas fa-radar-chart me-2"></i>Start Scanning
                </a>
            </div>
        `;
    }

    scansContainer.innerHTML = html;
}

// Global variable to track the current modal instance
let currentScanModal = null;

// Function to safely close and cleanup modal with aggressive cleanup
function closeScanModal() {
    console.log('Closing scan modal...');

    // Hide and dispose modal instance
    if (currentScanModal) {
        try {
            currentScanModal.hide();
            currentScanModal.dispose();
        } catch (e) {
            console.warn('Error disposing modal:', e);
        }
        currentScanModal = null;
    }

    // Force hide the modal element
    const modalElement = document.getElementById('scanDetailsModal');
    if (modalElement) {
        modalElement.classList.remove('show');
        modalElement.style.display = 'none';
        modalElement.setAttribute('aria-hidden', 'true');
        modalElement.removeAttribute('aria-modal');
        modalElement.removeAttribute('role');
    }

    // Aggressive backdrop cleanup - remove all possible backdrop elements
    const backdrops = document.querySelectorAll('.modal-backdrop, .modal-backdrop.fade, .modal-backdrop.show');
    backdrops.forEach(backdrop => {
        backdrop.remove();
    });

    // Reset body state completely
    document.body.classList.remove('modal-open');
    document.body.style.overflow = '';
    document.body.style.paddingRight = '';
    document.body.style.marginRight = '';

    // Remove any Bootstrap modal classes that might linger
    document.documentElement.style.overflow = '';
    document.documentElement.style.paddingRight = '';

    // Force a short delay and re-check
    setTimeout(() => {
        const remainingBackdrops = document.querySelectorAll('.modal-backdrop');
        remainingBackdrops.forEach(backdrop => backdrop.remove());

        if (document.body.classList.contains('modal-open')) {
            document.body.classList.remove('modal-open');
        }

        // Final cleanup
        document.body.style.cssText = document.body.style.cssText.replace(/overflow[^;]*;?/g, '');
        document.body.style.cssText = document.body.style.cssText.replace(/padding-right[^;]*;?/g, '');

        console.log('Modal cleanup completed');
    }, 150);
}

// Cleanup on page unload
window.addEventListener('beforeunload', closeScanModal);

// Emergency cleanup - detect if UI is locked and fix it
let lastInteraction = Date.now();
document.addEventListener('click', function(e) {
    lastInteraction = Date.now();

    // Check if we have lingering modal issues
    const backdrops = document.querySelectorAll('.modal-backdrop');
    const modalOpen = document.body.classList.contains('modal-open');
    const modalElement = document.getElementById('scanDetailsModal');
    const modalVisible = modalElement && modalElement.classList.contains('show');

    // If we have backdrops but no visible modal, or modal-open class without modal, cleanup
    if ((backdrops.length > 0 && !modalVisible) || (modalOpen && !modalVisible)) {
        console.warn('Detected UI lockup, performing emergency cleanup');
        closeScanModal();
    }
});

// Periodic check for stuck UI (every 5 seconds)
setInterval(() => {
    const timeSinceLastInteraction = Date.now() - lastInteraction;
    if (timeSinceLastInteraction > 5000) { // Only check if user hasn't interacted recently
        const backdrops = document.querySelectorAll('.modal-backdrop');
        const modalOpen = document.body.classList.contains('modal-open');
        const modalElement = document.getElementById('scanDetailsModal');
        const modalVisible = modalElement && modalElement.classList.contains('show');

        if ((backdrops.length > 0 && !modalVisible) || (modalOpen && !modalVisible)) {
            console.warn('Periodic check detected UI lockup, performing emergency cleanup');
            closeScanModal();
        }
    }
}, 5000);

// Escape key handler for emergency cleanup
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const backdrops = document.querySelectorAll('.modal-backdrop');
        const modalOpen = document.body.classList.contains('modal-open');
        const modalElement = document.getElementById('scanDetailsModal');
        const modalVisible = modalElement && modalElement.classList.contains('show');

        // If escape is pressed and UI seems stuck, force cleanup
        if ((backdrops.length > 0 && !modalVisible) || (modalOpen && !modalVisible)) {
            console.log('Escape key pressed, performing emergency cleanup');
            e.preventDefault();
            e.stopPropagation();
            closeScanModal();
        }
    }
});

// Named function for modal hidden event with aggressive cleanup
function handleModalHidden() {
    console.log('Modal hidden event triggered');

    if (currentScanModal) {
        try {
            currentScanModal.dispose();
        } catch (e) {
            console.warn('Error disposing modal in hidden event:', e);
        }
        currentScanModal = null;
    }

    // Immediate cleanup
    closeScanModal();
}

// Function to update modal content without creating new modal instance
function updateModalContent(data, scanId) {
    const modalTitle = document.getElementById('scanDetailsTitle');
    const modalBody = document.getElementById('scanDetailsBody');

    // Generate visualization tabs
    const vizTabs = data.visualizations.length > 0 ? 
        data.visualizations.map((viz, index) => {
            const vizName = viz.replace('.png', '').replace(/_/g, ' ');
            const isActive = index === 0 ? 'active' : '';
            return `<li class="nav-item" role="presentation">
                <button class="nav-link ${isActive}" id="viz-${index}-tab" data-bs-toggle="tab" data-bs-target="#viz-${index}" type="button" role="tab">
                    ${vizName}
                </button>
            </li>`;
        }).join('') : 
        '<li class="nav-item"><span class="nav-link disabled">No Visualizations</span></li>';

    const vizContent = data.visualizations.length > 0 ? 
        data.visualizations.map((viz, index) => {
            const isActive = index === 0 ? 'show active' : '';
            return `<div class="tab-pane fade ${isActive}" id="viz-${index}" role="tabpanel">
                <div class="visualization-container">
                    <img src="/images/${scanId}/${viz}" alt="${viz}" loading="lazy" />
                </div>
            </div>`;
        }).join('') : 
        '<div class="tab-pane fade show active"><div class="no-visualization">No visualizations available for this scan</div></div>';

    // Update modal title with origin information
    const originIcon = data.origin_type === 'timed_capture' ? 'clock' : data.origin_type === 'upload' ? 'upload' : 'question';
    modalTitle.innerHTML = `<i class="fas fa-${originIcon} me-2"></i>Scan Details - ${data.origin_description}`;

    modalBody.innerHTML = `
        <div class="alert alert-info mb-3">
            <i class="fas fa-info-circle me-2"></i>
            <strong>Source:</strong> ${data.origin_details}
        </div>

        <div class="row mb-4">
            <div class="col-md-3">
                <div class="metric-card">
                    <div class="metric-number">${data.total_connections}</div>
                    <div class="metric-label">Total Connections</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="metric-card">
                    <div class="metric-number" style="color: #dc3545;">${data.anomalies}</div>
                    <div class="metric-label">Anomalies</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="metric-card">
                    <div class="metric-number" style="color: #28a745;">${data.normal}</div>
                    <div class="metric-label">Normal</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="metric-card">
                    <div class="metric-number" style="color: #ffc107;">${data.anomaly_rate}%</div>
                    <div class="metric-label">Anomaly Rate</div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-6">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div>
                        <h6 class="mb-1">Connection Details</h6>
                        <small class="text-muted">
                            <i class="fas fa-file-archive text-success me-1"></i>
                            ${data.extracted_count || 0} connections have extracted PCAPs
                        </small>
                    </div>
                    <div class="d-flex align-items-center gap-3">
                        <button class="btn btn-sm btn-outline-primary" onclick="openForensicsFolder('${scanId}')">
                            <i class="fas fa-folder-open me-1"></i>Open Forensics Folder
                        </button>
                        <div class="d-flex flex-column gap-2">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="anomalyFilter" onchange="filterConnections('${scanId}')">
                                <label class="form-check-label" for="anomalyFilter">
                                    Show only anomalies
                                </label>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="extractedFilter" onchange="filterConnections('${scanId}')">
                                <label class="form-check-label" for="extractedFilter">
                                    Show only extracted
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table class="table table-dark table-sm">
                        <thead>
                            <tr>
                                <th width="40px">
                                    <input type="checkbox" id="selectAll" onchange="toggleSelectAll('${scanId}')">
                                </th>
                                <th>UID</th>
                                <th>Protocol</th>
                                <th>Score</th>
                                <th>Prediction</th>
                                <th width="80px">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="connectionsTableBody">
                            ${data.connections.map(conn => `
                                <tr data-prediction="${conn.prediction}" class="${conn.has_extracted_pcap ? 'extracted-connection' : ''}">
                                    <td><input type="checkbox" class="connection-checkbox" value="${conn.uid}"></td>
                                    <td>
                                        ${conn.has_extracted_pcap ? '<i class="fas fa-file-archive text-success me-1" title="PCAP extracted"></i>' : ''}
                                        ${conn.uid}
                                    </td>
                                    <td>${conn.proto || 'unknown'}</td>
                                    <td>${parseFloat(conn.score).toFixed(4)}</td>
                                    <td><span class="badge ${conn.prediction === 'anomaly' ? 'bg-danger' : 'bg-success'}">${conn.prediction}</span></td>
                                    <td>
                                        ${conn.has_extracted_pcap ? 
                                            `<button class="btn btn-xs btn-success" onclick="openPcapFile('${scanId}', '${conn.uid}')" title="Open extracted PCAP file">
                                                <i class="fas fa-external-link-alt"></i>
                                            </button>` :
                                            `<button class="btn btn-xs btn-outline-secondary" onclick="openPcapFile('${scanId}', '${conn.uid}')" title="PCAP not extracted yet">
                                                <i class="fas fa-external-link-alt"></i>
                                            </button>`
                                        }
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                <div class="mt-3">
                    <button class="btn btn-primary" onclick="extractSelectedConnections('${scanId}')" id="extractBtn" disabled>
                        <i class="fas fa-download me-1"></i>Extract Selected PCAPs
                    </button>
                    <span class="ms-2 text-muted" id="selectedCount">0 connections selected</span>
                    <div class="mt-2">
                        <small class="text-info">
                            <i class="fas fa-info-circle me-1"></i>
                            Tip: Connections with <i class="fas fa-file-archive text-success"></i> icons already have extracted PCAPs
                        </small>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <h6 class="mb-3">Visualizations</h6>
                <ul class="nav nav-tabs" id="visualizationTabs" role="tablist">
                    ${vizTabs}
                </ul>
                <div class="tab-content" id="visualizationTabContent">
                    ${vizContent}
                </div>
            </div>
        </div>
    `;

    // Store connections data for filtering
    window.currentScanConnections = data.connections;

    // Add event listeners for checkboxes
    updateSelectedCount();

    // Ensure filters are applied if they were already checked
    // This fixes the issue where the filter doesn't work when the modal is first loaded
    setTimeout(() => {
        const anomalyFilter = document.getElementById('anomalyFilter');
        const extractedFilter = document.getElementById('extractedFilter');

        if ((anomalyFilter && anomalyFilter.checked) || (extractedFilter && extractedFilter.checked)) {
            console.log('Applying initial filters');
            filterConnections(scanId);
        }
    }, 100);
}

// Track current extraction state to detect changes
let currentExtractionState = new Map();
let tableRefreshInterval = null;
let isExtractionInProgress = false;

// Function to update only the connections table while preserving modal state
function refreshConnectionsTable(scanId, preserveSelections = true) {
    const tableBody = document.getElementById('connectionsTableBody');
    if (!tableBody) return;

    // Store current user selections and filters
    const currentSelections = preserveSelections ? Array.from(document.querySelectorAll('.connection-checkbox:checked')).map(cb => cb.value) : [];
    const anomalyFilterState = document.getElementById('anomalyFilter')?.checked || false;
    const extractedFilterState = document.getElementById('extractedFilter')?.checked || false;
    const scrollPosition = tableBody.closest('.table').parentElement.scrollTop;

    console.log('Refreshing connections table for scan:', scanId);

    fetch(`/api/reports/scan/${scanId}/connections`)
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error('Error refreshing connections:', data.error);
            return;
        }

        // Update connections data
        window.currentScanConnections = data.connections;

        // Detect changes in extraction status
        let hasChanges = false;
        let newlyExtractedUIDs = [];
        const newExtractionState = new Map();

        data.connections.forEach(conn => {
            newExtractionState.set(conn.uid, conn.has_extracted_pcap);
            const oldState = currentExtractionState.get(conn.uid);
            if (oldState === false && conn.has_extracted_pcap === true) {
                hasChanges = true;
                newlyExtractedUIDs.push(conn.uid);
            }
        });

        // Update the extraction state tracking
        currentExtractionState = newExtractionState;

        // Regenerate table content
        tableBody.innerHTML = data.connections.map(conn => {
            const isNewlyExtracted = newlyExtractedUIDs.includes(conn.uid);
            return `
                <tr data-prediction="${conn.prediction}" class="${conn.has_extracted_pcap ? 'extracted-connection' : ''} ${isNewlyExtracted ? 'newly-extracted' : ''}">
                    <td><input type="checkbox" class="connection-checkbox" value="${conn.uid}"></td>
                    <td>
                        ${conn.has_extracted_pcap ? '<i class="fas fa-file-archive text-success me-1" title="PCAP extracted"></i>' : ''}
                        ${conn.uid}
                    </td>
                    <td>${conn.proto || 'unknown'}</td>
                    <td>${parseFloat(conn.score).toFixed(4)}</td>
                    <td><span class="badge ${conn.prediction === 'anomaly' ? 'bg-danger' : 'bg-success'}">${conn.prediction}</span></td>
                    <td>
                        ${conn.has_extracted_pcap ? 
                            `<button class="btn btn-xs btn-success" onclick="openPcapFile('${scanId}', '${conn.uid}')" title="Open extracted PCAP file">
                                <i class="fas fa-external-link-alt"></i>
                            </button>` :
                            `<button class="btn btn-xs btn-outline-secondary" onclick="openPcapFile('${scanId}', '${conn.uid}')" title="PCAP not extracted yet">
                                <i class="fas fa-external-link-alt"></i>
                            </button>`
                        }
                    </td>
                </tr>
            `;
        }).join('');

        // Restore user selections
        if (preserveSelections && currentSelections.length > 0) {
            currentSelections.forEach(uid => {
                const checkbox = document.querySelector(`.connection-checkbox[value="${uid}"]`);
                if (checkbox) checkbox.checked = true;
            });
        }

        // Restore filter states and reapply filters after DOM is ready
        setTimeout(() => {
            if (document.getElementById('anomalyFilter')) {
                document.getElementById('anomalyFilter').checked = anomalyFilterState;
            }
            if (document.getElementById('extractedFilter')) {
                document.getElementById('extractedFilter').checked = extractedFilterState;
            }

            // Reapply filters after a small delay to ensure DOM is ready
            filterConnections(scanId);
        }, 50);

        // Update UI counts and states
        updateSelectedCount();
        updateExtractedCount(data.extracted_count);

        // Restore scroll position
        setTimeout(() => {
            const scrollContainer = tableBody.closest('.table').parentElement;
            if (scrollContainer) scrollContainer.scrollTop = scrollPosition;
        }, 10);

        // Show notification if new extractions detected
        if (hasChanges && !isExtractionInProgress && newlyExtractedUIDs.length > 0) {
            showToast(`${newlyExtractedUIDs.length} new PCAP${newlyExtractedUIDs.length !== 1 ? 's' : ''} extracted and ready!`, true);

            // Highlight newly extracted rows briefly
            setTimeout(() => {
                document.querySelectorAll('.newly-extracted').forEach(row => {
                    row.style.backgroundColor = 'rgba(40, 167, 69, 0.2)';
                    row.style.transition = 'background-color 2s ease';
                    setTimeout(() => {
                        row.style.backgroundColor = '';
                        row.classList.remove('newly-extracted');
                    }, 2000);
                });
            }, 100);
        }

        console.log(`Table refreshed for scan ${scanId} - ${data.extracted_count} extracted PCAPs`);

    })
    .catch(error => {
        console.error('Error refreshing connections table:', error);
    });
}

// Function to update extracted count display
function updateExtractedCount(count) {
    const extractedCountDisplay = document.querySelector('.text-muted .fas.fa-file-archive');
    if (extractedCountDisplay) {
        const parentSmall = extractedCountDisplay.closest('small');
        if (parentSmall) {
            parentSmall.innerHTML = `<i class="fas fa-file-archive text-success me-1"></i>${count} connections have extracted PCAPs`;
        }
    }
}

// Function to initialize auto-refresh for a scan modal
function initializeAutoRefresh(scanId) {
    console.log('Initializing post-extraction refresh for scan:', scanId);

    // Clear any existing interval
    if (tableRefreshInterval) {
        clearInterval(tableRefreshInterval);
        tableRefreshInterval = null;
    }

    // Initialize the extraction state tracking with current data
    const tableBody = document.getElementById('connectionsTableBody');
    if (tableBody && window.currentScanConnections) {
        currentExtractionState.clear();
        window.currentScanConnections.forEach(conn => {
            currentExtractionState.set(conn.uid, conn.has_extracted_pcap);
        });
        console.log('Initialized extraction state with', currentExtractionState.size, 'connections');
    }

    // Store scanId for post-extraction refresh
    window.currentScanId = scanId;

    // Add cleanup listener for when modal is hidden
    const modalElement = document.getElementById('scanDetailsModal');
    if (modalElement) {
        modalElement.addEventListener('hidden.bs.modal', function() {
            console.log('Modal hidden, cleaning up refresh tracking');
            if (tableRefreshInterval) {
                clearInterval(tableRefreshInterval);
                tableRefreshInterval = null;
            }
            currentExtractionState.clear();
            isExtractionInProgress = false;
            window.currentScanId = null;
        }, { once: false }); // Allow multiple listeners but clean up properly
    }
}

// Function to trigger refresh after extraction completes
function triggerPostExtractionRefresh() {
    if (window.currentScanId && document.getElementById('scanDetailsModal').classList.contains('show')) {
        console.log('Triggering post-extraction refresh for scan:', window.currentScanId);
        refreshConnectionsTable(window.currentScanId, false); // Don't preserve selections since extraction clears them
    }
}

// Function to refresh scan details without creating new modal instance
function refreshCurrentScanDetails(scanId) {
    if (currentScanModal && document.getElementById('scanDetailsModal').classList.contains('show')) {
        // Just update the content of the existing modal
        const modalBody = document.getElementById('scanDetailsBody');
        modalBody.innerHTML = `
            <div class="text-center">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Refreshing...</span>
                </div>
            </div>
        `;

        // Fetch and update the content
        fetch(`/api/reports/scan/${scanId}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                modalBody.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                return;
            }

            // Update the modal content (reuse the existing modal content generation logic)
            updateModalContent(data, scanId);
        })
        .catch(error => {
            modalBody.innerHTML = `<div class="alert alert-danger">Error loading scan details: ${error.message}</div>`;
        });
    }
}

function viewScanDetails(scanId) {
    console.log('Opening scan details for:', scanId);

    // For debugging - let's also try a simple approach first
    if (window.debugMode) {
        const modalElement = document.getElementById('scanDetailsModal');
        const modalTitle = document.getElementById('scanDetailsTitle');
        const modalBody = document.getElementById('scanDetailsBody');

        modalTitle.textContent = `Scan Details - ${scanId}`;
        modalBody.innerHTML = '<div class="text-center"><div class="spinner-border text-primary"></div></div>';

        const modal = new bootstrap.Modal(modalElement);
        modal.show();

        fetch(`/api/reports/scan/${scanId}`)
        .then(response => response.json())
        .then(data => {
            console.log('DEBUG: Received data:', data);
            updateModalContent(data, scanId);

            // Initialize auto-refresh for debug mode too
            initializeAutoRefresh(scanId);
        })
        .catch(error => {
            console.error('DEBUG: Fetch error:', error);
            modalBody.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        });
        return;
    }

    // Force cleanup any existing issues first
    closeScanModal();

    const modalElement = document.getElementById('scanDetailsModal');
    const modalTitle = document.getElementById('scanDetailsTitle');
    const modalBody = document.getElementById('scanDetailsBody');

    // Check if modal elements exist
    if (!modalElement || !modalTitle || !modalBody) {
        console.error('Modal elements not found!');
        return;
    }

    // Wait a moment for cleanup to complete
    setTimeout(() => {
        console.log('Starting modal initialization for scan:', scanId);
        try {
            // Create new modal instance with defensive error handling
            currentScanModal = new bootstrap.Modal(modalElement, {
                backdrop: true,
                keyboard: true,
                focus: true
            });

            modalTitle.textContent = `Scan Details - ${scanId}`;
            modalBody.innerHTML = `
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            `;

            // Add event listeners with error handling
            modalElement.removeEventListener('hidden.bs.modal', handleModalHidden);
            modalElement.addEventListener('hidden.bs.modal', handleModalHidden);

            // Add click handler for backdrop
            modalElement.addEventListener('click', function(e) {
                if (e.target === modalElement) {
                    console.log('Backdrop clicked, closing modal');
                    closeScanModal();
                }
            });

            // Show modal with error handling
            try {
                currentScanModal.show();
                console.log('Modal shown successfully');

                // Fetch data AFTER modal is shown
                console.log('Fetching scan data for:', scanId);
                fetch(`/api/reports/scan/${scanId}`)
                .then(response => {
                    console.log('Received response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Received scan data:', data);
                    if (data.error) {
                        console.error('API returned error:', data.error);
                        modalBody.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                        return;
                    }

                    // Use the extracted content generation function
                    updateModalContent(data, scanId);

                    // Initialize auto-refresh after content is loaded
                    initializeAutoRefresh(scanId);
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    modalBody.innerHTML = `<div class="alert alert-danger">Error loading scan details: ${error.message}</div>`;
                });

            } catch (showError) {
                console.error('Error showing modal:', showError);
                closeScanModal();
                return;
            }

        } catch (error) {
            console.error('Error creating modal:', error);
            closeScanModal();
            return;
        }
    }, 100); // Reduced delay for faster loading
}


// Filter connections based on anomaly and extraction status toggles
function filterConnections(scanId) {
    console.log('Filtering connections for scan:', scanId);

    // Get filter states
    const showOnlyAnomalies = document.getElementById('anomalyFilter')?.checked || false;
    const showOnlyExtracted = document.getElementById('extractedFilter')?.checked || false;

    console.log('Filter states:', { showOnlyAnomalies, showOnlyExtracted });

    // Get table body with more robust error handling
    const tableBody = document.getElementById('connectionsTableBody');

    if (!tableBody) {
        console.error('Cannot find connectionsTableBody element');
        return;
    }

    // Get all rows
    const rows = tableBody.querySelectorAll('tr');

    if (rows.length === 0) {
        console.log('No rows found in connectionsTableBody');
        return;
    }

    // Track how many rows are shown/hidden
    let shownCount = 0;
    let hiddenCount = 0;
    let anomalyCount = 0;
    let extractedCount = 0;

    // Apply filters to each row
    rows.forEach(row => {
        const prediction = row.getAttribute('data-prediction');
        const hasExtractedClass = row.classList.contains('extracted-connection');

        if (prediction === 'anomaly') {
            anomalyCount++;
        }
        if (hasExtractedClass) {
            extractedCount++;
        }

        let showRow = true;

        // Apply anomaly filter
        if (showOnlyAnomalies && prediction !== 'anomaly') {
            showRow = false;
        }

        // Apply extraction filter
        if (showOnlyExtracted && !hasExtractedClass) {
            showRow = false;
        }

        // Set display style
        row.style.display = showRow ? '' : 'none';

        // Count results
        if (showRow) {
            shownCount++;
        } else {
            hiddenCount++;
        }
    });

    // Update filter status message
    updateFilterStatusReports(scanId, showOnlyAnomalies, showOnlyExtracted, anomalyCount, extractedCount, shownCount, rows.length);

    // Reset checkboxes when filtering
    const selectAllCheckbox = document.getElementById('selectAll');
    if (selectAllCheckbox) {
        selectAllCheckbox.checked = false;
    }

    document.querySelectorAll('.connection-checkbox').forEach(cb => cb.checked = false);
    updateSelectedCount();
}

// Update filter status message for reports modal
function updateFilterStatusReports(scanId, showOnlyAnomalies, showOnlyExtracted, anomalyCount, extractedCount, shownCount, totalCount) {
    let statusEl = document.getElementById(`filter-status-${scanId}`);
    if (!statusEl) {
        // Create status element if it doesn't exist
        statusEl = document.createElement('div');
        statusEl.id = `filter-status-${scanId}`;
        statusEl.className = 'alert alert-info mt-2 mb-0';
        
        // Insert after the connections table
        const tableContainer = document.querySelector('.table-responsive');
        if (tableContainer && tableContainer.parentNode) {
            tableContainer.parentNode.insertBefore(statusEl, tableContainer.nextSibling);
        }
    }
    
    if (showOnlyAnomalies || showOnlyExtracted) {
        let filterText = [];
        if (showOnlyAnomalies) filterText.push(`${anomalyCount} anomalies`);
        if (showOnlyExtracted) filterText.push(`${extractedCount} extracted`);
        
        statusEl.innerHTML = `<i class="fas fa-filter me-2"></i>Showing ${shownCount} of ${filterText.join(' and ')} (${totalCount} total connections)`;
        statusEl.style.display = 'block';
    } else {
        statusEl.style.display = 'none';
    }
}

// Toggle select all checkboxes
function toggleSelectAll(scanId) {
    const selectAll = document.getElementById('selectAll');
    const checkboxes = document.querySelectorAll('.connection-checkbox');
    const visibleCheckboxes = Array.from(checkboxes).filter(cb => 
        cb.closest('tr').style.display !== 'none'
    );

    visibleCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAll.checked;
    });

    updateSelectedCount();
}

// Update selected count and extract button state
function updateSelectedCount() {
    // Add event listeners to connection checkboxes
    document.querySelectorAll('.connection-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', updateSelectedCount);
    });

    const selectedCheckboxes = document.querySelectorAll('.connection-checkbox:checked');
    const count = selectedCheckboxes.length;

    // Check how many selected connections are already extracted
    let alreadyExtractedCount = 0;
    selectedCheckboxes.forEach(checkbox => {
        const row = checkbox.closest('tr');
        if (row.classList.contains('extracted-connection')) {
            alreadyExtractedCount++;
        }
    });

    // Update the count display with warning if needed
    let countText = `${count} connection${count !== 1 ? 's' : ''} selected`;
    if (alreadyExtractedCount > 0) {
        countText += ` <span class="text-warning">(${alreadyExtractedCount} already extracted)</span>`;
    }
    document.getElementById('selectedCount').innerHTML = countText;

    document.getElementById('extractBtn').disabled = count === 0;

    // Update extract button text and style based on warnings
    const extractBtn = document.getElementById('extractBtn');
    if (extractBtn && alreadyExtractedCount > 0) {
        if (alreadyExtractedCount === count) {
            // All selected are already extracted
            extractBtn.innerHTML = '<i class="fas fa-exclamation-triangle me-1"></i>All Already Extracted';
            extractBtn.className = 'btn btn-warning';
        } else {
            // Some are already extracted
            extractBtn.innerHTML = `<i class="fas fa-download me-1"></i>Extract Selected (${alreadyExtractedCount} duplicate${alreadyExtractedCount !== 1 ? 's' : ''})`;
            extractBtn.className = 'btn btn-warning';
        }
    } else if (extractBtn) {
        // Normal extraction
        extractBtn.innerHTML = '<i class="fas fa-download me-1"></i>Extract Selected PCAPs';
        extractBtn.className = 'btn btn-primary';
    }

    // Update select all checkbox state
    const allCheckboxes = Array.from(document.querySelectorAll('.connection-checkbox')).filter(cb => 
        cb.closest('tr').style.display !== 'none'
    );
    const checkedBoxes = Array.from(document.querySelectorAll('.connection-checkbox:checked')).filter(cb => 
        cb.closest('tr').style.display !== 'none'
    );

    const selectAllCheckbox = document.getElementById('selectAll');
    if (selectAllCheckbox) {
        selectAllCheckbox.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < allCheckboxes.length;
        selectAllCheckbox.checked = allCheckboxes.length > 0 && checkedBoxes.length === allCheckboxes.length;
    }
}

// Show toast notification
function showToast(message, isSuccess = true) {
    const toast = document.getElementById('extractionToast');
    const toastBody = document.getElementById('toastBody');
    const toastHeader = toast.querySelector('.toast-header');
    const icon = toastHeader.querySelector('i');

    // Update toast styling based on success/error
    if (isSuccess) {
        toast.className = 'toast border-success';
        icon.className = 'fas fa-check-circle me-2 text-success';
        toastHeader.style.backgroundColor = 'rgba(40, 167, 69, 0.1)';
    } else {
        toast.className = 'toast border-danger';
        icon.className = 'fas fa-exclamation-circle me-2 text-danger';
        toastHeader.style.backgroundColor = 'rgba(220, 53, 69, 0.1)';
    }

    toastBody.innerHTML = message;

    // Show the toast
    const bsToast = new bootstrap.Toast(toast, {
        autohide: true,
        delay: 5000
    });
    bsToast.show();
}

// Extract selected connections as separate PCAPs
function extractSelectedConnections(scanId) {
    const selectedCheckboxes = document.querySelectorAll('.connection-checkbox:checked');
    const selectedUIDs = Array.from(selectedCheckboxes).map(cb => cb.value);

    if (selectedUIDs.length === 0) {
        showToast('Please select at least one connection to extract.', false);
        return;
    }

    // Check for already extracted connections
    let alreadyExtractedUIDs = [];
    let newUIDs = [];

    selectedCheckboxes.forEach(checkbox => {
        const row = checkbox.closest('tr');
        const uid = checkbox.value;
        if (row.classList.contains('extracted-connection')) {
            alreadyExtractedUIDs.push(uid);
        } else {
            newUIDs.push(uid);
        }
    });

    // Show confirmation dialog if there are already extracted connections
    if (alreadyExtractedUIDs.length > 0) {
        const message = alreadyExtractedUIDs.length === selectedUIDs.length 
            ? `All ${alreadyExtractedUIDs.length} selected connections already have extracted PCAPs. This will re-extract them (overwriting existing files).`
            : `${alreadyExtractedUIDs.length} of ${selectedUIDs.length} selected connections already have extracted PCAPs:\n\n` +
              `Already extracted: ${alreadyExtractedUIDs.slice(0, 3).join(', ')}${alreadyExtractedUIDs.length > 3 ? ` and ${alreadyExtractedUIDs.length - 3} more` : ''}\n` +
              `New extractions: ${newUIDs.length}\n\n` +
              `Continue anyway? This will re-extract existing PCAPs (overwriting files).`;

        if (!confirm(message)) {
            return;
        }
    }

    // Show loading state
    const extractBtn = document.getElementById('extractBtn');
    const originalText = extractBtn.innerHTML;
    extractBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Extracting...';
    extractBtn.disabled = true;

    // Set extraction in progress flag for auto-refresh logic
    isExtractionInProgress = true;

    console.log('Sending extraction request with scan_id:', scanId, 'UIDs:', selectedUIDs);

    fetch('/api/reports/extract_pcaps', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            scan_id: scanId,
            connection_uids: selectedUIDs
        })
    })
    .then(response => {
        console.log('Extraction response status:', response.status);
        return response.json();
    })
    .then(data => {
        console.log('Extraction response data:', data);

        if (data.success) {
            let message = `Successfully extracted ${data.extracted_count} PCAP file${data.extracted_count !== 1 ? 's' : ''} to:<br><code>${data.output_path}</code>`;

            if (data.warnings && data.warnings.length > 0) {
                message += `<br><br><small class="text-warning">Some extractions had warnings - check console for details.</small>`;
                console.warn('Extraction warnings:', data.warnings);
            }

            // Reset selections
            document.querySelectorAll('.connection-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('selectAll').checked = false;
            updateSelectedCount();

            // Show success message
            showToast(message, true);

            // Trigger post-extraction refresh to show changes
            setTimeout(() => {
                triggerPostExtractionRefresh();
            }, 1000); // Small delay to allow backend to complete file operations
        } else {
            console.error('Extraction failed:', data.error);
            showToast(`Error extracting PCAPs: ${data.error}`, false);
        }
    })
    .catch(error => {
        showToast(`Error extracting PCAPs: ${error.message}`, false);
    })
    .finally(() => {
        extractBtn.innerHTML = originalText;
        extractBtn.disabled = document.querySelectorAll('.connection-checkbox:checked').length === 0;

        // Clear extraction in progress flag
        isExtractionInProgress = false;
    });
}

// Open forensics folder for a scan
function openForensicsFolder(scanId) {
    fetch(`/api/reports/open_forensics_folder/${scanId}`)
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(data.message, true);
        } else {
            showToast(data.message || data.error, false);
        }
    })
    .catch(error => {
        showToast('Error opening forensics folder: ' + error.message, false);
    });
}

// Open specific PCAP file
function openPcapFile(scanId, uid) {
    fetch(`/api/reports/open_pcap_file/${scanId}/${uid}`)
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(data.message, true);
        } else {
            showToast(data.message || data.error, false);
        }
    })
    .catch(error => {
        showToast('Error opening PCAP file: ' + error.message, false);
    });
}

</script>
{% endblock %}
